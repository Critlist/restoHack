#!/usr/bin/env bash
set -euo pipefail

# One-click release helper for restoHack (or any repo using prepare-release.sh)
# - Auto-bumps semver (patch by default) from the latest tag (or v0.1.0 if none)
# - Creates an annotated tag
# - Pushes commit and tag to origin
# - Runs ./prepare-release.sh with the new version
# - Optionally creates a GitHub Release via gh (if installed), uploading artifacts from release-$VERSION/*
#
# Usage:
#   ./release.sh [major|minor|patch] [--no-gh] [--dry-run] [--yes]
# Defaults:
#   bump = patch, gh = on (if available), dry-run = off, confirm = interactive
#
# Examples:
#   ./release.sh                # bump patch (v1.2.3 -> v1.2.4), tag, push, prepare, gh release
#   ./release.sh minor --no-gh  # bump minor only and skip GitHub Release
#   ./release.sh major --dry-run
#
# Requirements:
#   - git, bash
#   - gh (optional) authenticated with repo scope for GitHub release publishing
#   - ./prepare-release.sh present & executable in repo root
#
# Notes:
#   - This script assumes your default branch is 'master'. Set BRANCH if different.
#   - It refuses to run if the working tree isn't clean (use --dry-run to preview).

BRANCH="${BRANCH:-master}"
BUMP_KIND="patch"
USE_GH="auto"     # auto|on|off
DRY_RUN="false"
ASSUME_YES="false"

confirm() {
  if [[ "${ASSUME_YES}" == "true" ]]; then
    return 0
  fi
  read -r -p "$1 [y/N] " ans
  [[ "${ans,,}" == "y" || "${ans,,}" == "yes" ]]
}

die() { echo "error: $*" >&2; exit 1; }

have_cmd() { command -v "$1" >/dev/null 2>&1; }

parse_args() {
  while [[ $# -gt 0 ]]; do
    case "${1}" in
      major|minor|patch) BUMP_KIND="$1"; shift ;;
      --no-gh) USE_GH="off"; shift ;;
      --gh)    USE_GH="on"; shift ;;
      --dry-run) DRY_RUN="true"; shift ;;
      --yes|-y) ASSUME_YES="true"; shift ;;
      -h|--help)
        sed -n '1,80p' "$0"
        exit 0
        ;;
      *)
        die "unknown argument: $1"
        ;;
    esac
  done
}

ensure_in_repo_root() {
  [[ -d .git ]] || die "Run from the repo root (no .git found)."
}

ensure_prepare_exists() {
  [[ -x ./prepare-release.sh ]] || die "./prepare-release.sh not found or not executable."
}

ensure_clean_worktree() {
  if ! git diff --quiet || ! git diff --cached --quiet; then
    die "Working tree has uncommitted changes. Commit/stash first."
  fi
}

ensure_branch() {
  local cur
  cur=$(git rev-parse --abbrev-ref HEAD)
  [[ "${cur}" == "${BRANCH}" ]] || die "You are on '${cur}', expected '${BRANCH}'."
}

ensure_up_to_date() {
  git fetch origin "${BRANCH}"
  local local_hash remote_hash
  local_hash=$(git rev-parse "${BRANCH}")
  remote_hash=$(git rev-parse "origin/${BRANCH}")
  if [[ "${local_hash}" != "${remote_hash}" ]]; then
    die "Local ${BRANCH} (${local_hash}) != origin/${BRANCH} (${remote_hash}). Pull first."
  fi
}

current_tag() {
  if git describe --tags --abbrev=0 >/dev/null 2>&1; then
    git describe --tags --abbrev=0
  else
    die "No tags found in repository. Create an initial tag first (e.g., git tag v1.0.0)"
  fi
}

is_semver() {
  [[ "$1" =~ ^v([0-9]+)\.([0-9]+)\.([0-9]+)$ ]]
}

bump_semver() {
  local cur="$1" kind="$2"
  if ! is_semver "${cur}"; then
    echo "v0.1.0"
    return 0
  fi
  local major minor patch
  major="${BASH_REMATCH[1]}"
  minor="${BASH_REMATCH[2]}"
  patch="${BASH_REMATCH[3]}"
  case "${kind}" in
    major) major=$((major+1)); minor=0; patch=0 ;;
    minor) minor=$((minor+1)); patch=0 ;;
    patch) patch=$((patch+1)) ;;
    *) die "unknown bump kind: ${kind}" ;;
  esac
  printf 'v%d.%d.%d\n' "${major}" "${minor}" "${patch}"
}

annotated_tag() {
  local tag="$1"
  if [[ "${DRY_RUN}" == "true" ]]; then
    echo "[dry-run] git tag -a ${tag} -m \"Release ${tag}\""
    return 0
  fi
  git tag -a "${tag}" -m "Release ${tag}"
}

push_branch_and_tag() {
  local tag="$1"
  if [[ "${DRY_RUN}" == "true" ]]; then
    echo "[dry-run] git push origin ${BRANCH}"
    echo "[dry-run] git push origin ${tag}"
    return 0
  fi
  git push origin "${BRANCH}"
  git push origin "${tag}"
}

run_prepare() {
  local tag="$1"
  if [[ "${DRY_RUN}" == "true" ]]; then
    echo "[dry-run] ./prepare-release.sh ${tag}"
    return 0
  fi
  ./prepare-release.sh "${tag}"
}

auto_detect_gh() {
  if [[ "${USE_GH}" == "auto" ]]; then
    if have_cmd gh; then USE_GH="on"; else USE_GH="off"; fi
  fi
}

github_release() {
  local tag="$1"; shift
  local rel_dir="release-${tag}"
  if [[ ! -d "${rel_dir}" ]]; then
    echo "warning: ${rel_dir} not found; skipping gh release upload."
    return 0
  fi
  if [[ "${USE_GH}" != "on" ]]; then
    echo "info: gh disabled; skipping GitHub Release."
    return 0
  fi
  
  # Use the RELEASE_NOTES.md generated by prepare-release.sh
  local notes_file="${rel_dir}/RELEASE_NOTES.md"
  if [[ ! -f "${notes_file}" ]]; then
    echo "warning: ${notes_file} not found; using default message."
    notes_file=""
  fi
  
  if [[ "${DRY_RUN}" == "true" ]]; then
    if [[ -n "${notes_file}" ]]; then
      echo "[dry-run] gh release create ${tag} ${rel_dir}/* --title \"restoHack ${tag}\" --notes-file \"${notes_file}\""
    else
      echo "[dry-run] gh release create ${tag} ${rel_dir}/* --title \"restoHack ${tag}\" --notes \"Automated release ${tag}\""
    fi
    return 0
  fi
  
  if [[ -n "${notes_file}" ]]; then
    gh release create "${tag}" "${rel_dir}"/* --title "restoHack ${tag}" --notes-file "${notes_file}"
  else
    gh release create "${tag}" "${rel_dir}"/* --title "restoHack ${tag}" --notes "Automated release ${tag}"
  fi
}

main() {
  parse_args "$@"
  ensure_in_repo_root
  ensure_prepare_exists
  ensure_clean_worktree
  ensure_branch
  ensure_up_to_date

  local cur_tag next_tag
  cur_tag=$(current_tag)
  next_tag=$(bump_semver "${cur_tag}" "${BUMP_KIND}")

  echo "Current tag: ${cur_tag}"
  echo "Next tag:    ${next_tag} (bump: ${BUMP_KIND})"

  if ! confirm "Proceed with tagging, pushing, preparing, and publishing?"; then
    echo "Aborted."
    exit 1
  fi

  annotated_tag "${next_tag}"
  push_branch_and_tag "${next_tag}"

  auto_detect_gh
  echo "Running prepare-release for ${next_tag} ..."
  run_prepare "${next_tag}"

  echo "Publishing GitHub release (gh=${USE_GH}) ..."
  github_release "${next_tag}"

  echo "Done. Released ${next_tag}."
}

main "$@"
